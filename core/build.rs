use convert_case::{Case, Casing};
use core::panic;
use regex::Regex;
use std::{
    collections::{HashMap, HashSet},
    io::Write,
    path::Path,
    vec,
};
use std::{env, fs};
use walkdir::WalkDir;

fn write_header_block() -> String {
    write_header_out("block")
}

fn write_header_item() -> String {
    write_header_out("item")
}

fn write_header_out(out_name: &str) -> String {
    let mut file_str = String::new();
    file_str.push_str(&format!("// This file is generated by build.rs\n"));
    file_str.push_str(&format!(
        "use {}::Simple{};\n\n",
        out_name,
        out_name.to_case(Case::Pascal)
    ));
    file_str.push_str(&format!(
        "pub struct Register{} {{
    pub new: fn(Simple{}) -> Simple{},
    pub load: fn(Simple{}) -> Simple{},
    pub tags: &'static quickphf::PhfMap<&'static str, &'static str>,
    pub name: &'static str,
}}\n\n",
        out_name.to_case(Case::Pascal),
        out_name.to_case(Case::Pascal),
        out_name.to_case(Case::Pascal),
        out_name.to_case(Case::Pascal),
        out_name.to_case(Case::Pascal)
    ));
    file_str
}

fn capture_register_block(
    file_content: &str,
    file_str: &mut String,
    block_register: &mut Vec<String>,
    lib_path: &str,
) {
    capture_register_out(file_content, file_str, block_register, "Block", lib_path);
}

fn capture_register_item(
    file_content: &str,
    file_str: &mut String,
    item_register: &mut Vec<String>,
    lib_path: &str,
) {
    capture_register_out(file_content, file_str, item_register, "Item", lib_path);
}

fn capture_register_out(
    file_content: &str,
    file_str: &mut String,
    out_register: &mut Vec<String>,
    out_name: &str,
    lib_path: &str,
) {
    let re =
        Regex::new(format!(r"#\[register\({}\)\][\n\r]*pub mod *(\w+)", out_name).as_str()).unwrap();
    for cap in re.captures_iter(&file_content) {
        file_str.push_str(&format!("pub use {}::{};\n", lib_path, &cap[1]));
        out_register.push(cap[1].to_string());
    }
}

fn write_static_blockdata(
    file_str: &mut String,
    block_register: &Vec<String>,
    tags: &HashMap<String, Vec<(String, String)>>,
) {
    write_static_outdata(file_str, block_register, tags);
}

fn write_static_itemdata(
    file_str: &mut String,
    item_register: &Vec<String>,
    tags: &HashMap<String, Vec<(String, String)>>,
) {
    write_static_outdata(file_str, item_register, tags);
}

fn write_static_outdata(
    file_str: &mut String,
    out_register: &Vec<String>,
    tags: &HashMap<String, Vec<(String, String)>>,
) {
    let mut n = 0;

    for i in out_register {
        file_str.push_str(&format!(
            "pub const {}_ID: i32 = {};\n",
            &i.to_case(Case::UpperSnake),
            n
        ));
        file_str.push_str(&format!(
            "pub static {}_TAGS: &quickphf::PhfMap<&'static str, &'static str> = &",
            &i.to_case(Case::UpperSnake)
        ));
        let mut keys = vec![];
        let mut values = vec![];
        if let Some(tags) = tags.get(i) {
            for tag in tags {
                keys.push(tag.0.as_str());
                values.push(tag.1.as_str());
            }
        }
        let code = quickphf_codegen::build_map(&keys, &values);
        file_str.push_str(&format!("{};\n\n", code));
        n += 1;
    }
}

fn write_register_block(file_str: &mut String, block_register: &Vec<String>) {
    write_register_out(file_str, block_register, "block");
}

fn write_register_item(file_str: &mut String, item_register: &Vec<String>) {
    write_register_out(file_str, item_register, "item");
}

fn write_register_out(file_str: &mut String, out_register: &Vec<String>, out_name: &str) {
    file_str.push_str(
        format!(
            "\npub static REGISTER_{}: &[Register{}] = &[\n",
            out_name.to_uppercase(),
            &out_name.to_case(Case::Pascal)
        )
        .as_str(),
    );

    for i in out_register {
        file_str.push_str(&format!(
            "    Register{} {{new: {}::new, load: {}::load, tags: {}_TAGS, name: {}::NAME}},\n",
            &out_name.to_case(Case::Pascal),
            i,
            i,
            &i.to_case(Case::UpperSnake),
            i
        ));
    }

    file_str.push_str("];\n\n");
}

fn write_block_file(file_str: &str) {
    write_output_file(file_str, "blocks.rs")
}

fn write_item_file(file_str: &str) {
    write_output_file(file_str, "items.rs");
}

fn write_output_file(file_str: &str, file_name: &str) {
    let path = env::current_dir().unwrap();
    let path = Path::new(&path).join("src");
    if !path.join("register").exists() {
        fs::create_dir(path.join("register")).unwrap();
    }
    let file_outpath = path.join("register").join(file_name);

    let mut file_item = fs::File::create(file_outpath).unwrap();
    file_item.write_all(file_str.as_bytes()).unwrap();

    file_item.flush().unwrap();
}

fn capture_register_complement_block(
    file_content: &str,
    file_str: &mut String,
    block_register: &mut Vec<String>,
    lib_path: &str,
    tags_values: &HashMap<String, HashSet<String>>,
    tags: &mut HashMap<String, Vec<(String, String)>>,
    after_tags_heritage: &mut Vec<(String, String)>,
) {
    capture_register_complement_out(
        file_content,
        file_str,
        block_register,
        "Block",
        lib_path,
        tags_values,
        tags,
        after_tags_heritage,
    );
}

fn capture_register_complement_item(
    file_content: &str,
    file_str: &mut String,
    item_register: &mut Vec<String>,
    lib_path: &str,
    tags_values: &HashMap<String, HashSet<String>>,
    tags: &mut HashMap<String, Vec<(String, String)>>,
    after_tags_heritage: &mut Vec<(String, String)>,
) {
    capture_register_complement_out(
        file_content,
        file_str,
        item_register,
        "Item",
        lib_path,
        tags_values,
        tags,
        after_tags_heritage,
    );
}

fn capture_register_complement_out(
    file_content: &str,
    file_str: &mut String,
    out_register: &mut Vec<String>,
    out_name: &str,
    lib_path: &str,
    tags_values: &HashMap<String, HashSet<String>>,
    tags: &mut HashMap<String, Vec<(String, String)>>,
    after_tags_heritage: &mut Vec<(String, String)>,
) {
    let re = Regex::new(
        format!(
            r#"#\[register_complement\({},"(\w+)"\)\][\n\r]*pub +mod +(\w+)"#,
            out_name
        )
        .as_str(),
    )
    .unwrap();
    for cap in re.captures_iter(&file_content) {
        let tag = cap[1].to_string();
        let original_name = cap[2].to_string();
        for tags_value in tags_values.get(&tag).unwrap() {
            let name = &original_name.replace("value", tags_value);
            let name = name.replace("Value", &tags_value.to_case(Case::Pascal));
            file_str.push_str(&format!("pub use {}::{};\n", lib_path, &name));
            out_register.push(name.clone());
            tags.entry(name.clone())
                .or_insert(vec![])
                .push((tag.clone(), tags_value.clone()));
            after_tags_heritage.push((name.clone(), original_name.clone()));
        }
    }
}

fn finish_tags_heritage(
    tags: &mut HashMap<String, Vec<(String, String)>>,
    after_tags_heritage: &mut Vec<(String, String)>,
) {
    for (name, original_name) in after_tags_heritage {
        let l = tags.get(original_name).unwrap().clone();
        for (tag, value) in l {
            tags.entry(name.clone())
                .or_insert(vec![])
                .push((tag.clone(), value.clone()));
        }
    }
}

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=.");

    let mut file_block_str = write_header_block();

    let mut file_item_str = write_header_item();

    let mut block_register = vec![];
    let mut item_register = vec![];

    let mut tags: HashMap<String, Vec<(String, String)>> = HashMap::new();
    let mut tags_values: HashMap<String, HashSet<String>> = HashMap::new();

    let mut after_tags_heritage: Vec<(String, String)> = vec![];

    for entry in WalkDir::new("..")
        .into_iter()
        .filter_map(Result::ok)
        .filter(|e| {
            !e.file_type().is_dir()
                && !e.path().to_str().unwrap().contains("target")
                && !e.path().to_str().unwrap().contains("git")
        })
    {
        let path = entry.path();
        let path_without_filename = path.parent().unwrap();
        let path_str = path.to_str().unwrap();

        let lib_path = path_str
            .replace("src\\", "")
            .replace("..\\", "")
            .replace(".\\", "")
            .replace("\\", "::")
            .replace("src/", "")
            .replace("../", "")
            .replace(".rs", "")
            .replace("/", "::")
            .replace("core", "crate");

        if path_str.ends_with(".rs") {
            let file_content = fs::read_to_string(path).unwrap();

            capture_register_block(
                &file_content,
                &mut file_block_str,
                &mut block_register,
                &lib_path,
            );
            capture_register_item(
                &file_content,
                &mut file_item_str,
                &mut item_register,
                &lib_path,
            );

            let re = Regex::new(r####"[\n\r]+add_tag!\((\w+) *, *"(\w+)" *, *"(\w+)" *\);"####).unwrap();
            for cap in re.captures_iter(&file_content) {
                tags.entry(cap[1].to_string())
                    .or_insert(vec![])
                    .push((cap[2].to_string(), cap[3].to_string()));
                tags_values
                    .entry(cap[2].to_string())
                    .or_insert(HashSet::new())
                    .insert(cap[3].to_string());
            }

            let re = Regex::new(r####"[\n\r]+add_tag_from_file!\((\w+) *, *"([\w_.]+)" *\);"####).unwrap();
            for cap in re.captures_iter(&file_content) {
                let tags = tags.entry(cap[1].to_string()).or_insert(vec![]);
                let file_content =
                    fs::read_to_string(path_without_filename.join(cap[2].to_string()));
                let file_content = match file_content {
                    Ok(file_content) => file_content,
                    Err(_) => panic!(
                        "File not found: {}",
                        path_without_filename
                            .join(cap[2].to_string())
                            .to_string_lossy()
                    ),
                };

                let re = Regex::new(r####""*([\w_]+)"* *: *"*(\w+)"*"####).unwrap();
                for cap in re.captures_iter(&file_content) {
                    tags.push((cap[1].to_string(), cap[2].to_string()));
                }
            }

            capture_register_complement_block(
                &file_content,
                &mut file_block_str,
                &mut block_register,
                &lib_path,
                &tags_values,
                &mut tags,
                &mut after_tags_heritage,
            );
            capture_register_complement_item(
                &file_content,
                &mut file_item_str,
                &mut item_register,
                &lib_path,
                &tags_values,
                &mut tags,
                &mut after_tags_heritage,
            );
        }
    }

    finish_tags_heritage(&mut tags, &mut after_tags_heritage);

    let path = Path::new(&env::var("CARGO_MANIFEST_DIR").unwrap())
        .parent()
        .unwrap()
        .to_path_buf();
    if path.join("tags_output").exists() {
        fs::remove_dir_all(path.join("tags_output")).unwrap();
    }
    fs::create_dir(path.join("tags_output")).unwrap();

    for (key, value) in tags_values {
        let mut file =
            fs::File::create(path.join("tags_output").join(format!("{}.txt", key))).unwrap();
        file.write_all(itertools::join(&value, "\n").as_bytes())
            .unwrap();
        file.flush().unwrap();
    }

    write_static_blockdata(&mut file_block_str, &block_register, &tags);
    write_register_block(&mut file_block_str, &block_register);
    write_block_file(&mut file_block_str);

    write_static_itemdata(&mut file_item_str, &item_register, &tags);
    write_register_item(&mut file_item_str, &item_register);
    write_item_file(&mut file_item_str)
}
