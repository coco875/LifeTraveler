use core::panic;
use std::{path::Path, vec, io::Write, collections::HashMap};
use regex::Regex;
use std::{env, fs};
use walkdir::WalkDir;

fn write_header_block() -> String {
    let mut file_block_str = String::new();
    file_block_str.push_str("// This file is generated by build.rs\n");
    file_block_str.push_str("use block::SimpleBlock;\n\n");
    file_block_str.push_str("pub struct RegisterBlock {
    pub new: fn(SimpleBlock) -> SimpleBlock,
    pub load: fn(SimpleBlock) -> SimpleBlock,
    pub tags: &'static quickphf::PhfMap<&'static str, &'static str>,
    pub name: &'static str,
}\n\n");
    file_block_str
}

fn capture_register_block(file_content: &str, file_str: &mut String, block_register: &mut Vec<String>, lib_path: &str) {
    let re = Regex::new(r"#\[register\(Block\)\][\n\r]*pub mod (\w+)").unwrap();
    for cap in re.captures_iter(file_content) {
        file_str.push_str(&format!("pub use {}::{};\n", lib_path, &cap[1]));
        block_register.push(cap[1].to_string());
    }
}

fn write_static_blockdata(file_str: &mut String, block_register: &Vec<String>, tags: &HashMap<String, Vec<(String,String)>>) {
    let mut n = 0;
    
    for i in block_register {
        file_str.push_str(&format!("pub const {}_ID: u16 = {};\n", i.to_uppercase(), n));
        file_str.push_str(&format!("pub static {}_TAGS: &quickphf::PhfMap<&'static str, &'static str> = &", i.to_uppercase()));
        let mut keys = vec![];
        let mut values = vec![];
        if let Some(tags) = tags.get(i) {
            for tag in tags {
                keys.push(tag.0.as_str());
                values.push(tag.1.as_str());
            }
        }
        let code = quickphf_codegen::build_map(&keys, &values);
        file_str.push_str(&format!("{};\n\n", code));
        n += 1;
    }
}

fn write_register_block(file_str: &mut String, block_register: &Vec<String>) {
    file_str.push_str("\npub static REGISTER_BLOCK: &[RegisterBlock] = &[\n");
    
    for i in block_register {
        file_str.push_str(&format!("    RegisterBlock {{new: {}::new, load: {}::load, tags: {}_TAGS, name: {}::NAME}},\n", i, i, i.to_uppercase(), i));
    }
    
    file_str.push_str("];\n\n");
}

fn write_block_file(file_str: &str) {
    let path = env::current_dir().unwrap();
    let file_outpath = Path::new(&path).join("src").join("blocks.rs");

    let mut file_block = fs::File::create(file_outpath).unwrap();
    file_block.write_all(file_str.as_bytes()).unwrap();
    file_block.flush().unwrap();

    let path = Path::new(&env::var("OUT_DIR").unwrap()).join("blocks.rs");
    let mut file_item = fs::File::create(path).unwrap();
    file_item.write_all(file_str.as_bytes()).unwrap();

    file_item.flush().unwrap();
}

fn write_header_item() -> String {
    let mut file_item_str = String::new();
    file_item_str.push_str("// This file is generated by build.rs\n");
    file_item_str.push_str("use item::SimpleItem;\n\n");
    file_item_str.push_str("pub struct RegisterItem {
        pub new: fn(SimpleItem) -> SimpleItem,
        pub load: fn(SimpleItem) -> SimpleItem,
        pub tags: &'static quickphf::PhfMap<&'static str, &'static str>,
        pub name: &'static str,
    }\n\n");
    file_item_str
}

fn capture_register_item(file_content: &str, file_str: &mut String, item_register: &mut Vec<String>, lib_path: &str) {
    let re = Regex::new(r"#\[register\(Item\)\]\npub mod (\w+)").unwrap();
    for cap in re.captures_iter(&file_content) {
        file_str.push_str(&format!("pub use {}::{};\n", lib_path, &cap[1]));
        item_register.push(cap[1].to_string());
    }
}

fn write_static_itemdata(file_str: &mut String, item_register: &Vec<String>, tags: &HashMap<String, Vec<(String,String)>>) {
    let mut n = 0;
    
    for i in item_register {
        file_str.push_str(&format!("pub const {}_ID: i32 = {};\n", i.to_uppercase(), n));
        file_str.push_str(&format!("pub static {}_TAGS: &quickphf::PhfMap<&'static str, &'static str> = &", i.to_uppercase()));
        let mut keys = vec![];
        let mut values = vec![];
        if let Some(tags) = tags.get(i) {
            for tag in tags {
                keys.push(tag.0.as_str());
                values.push(tag.1.as_str());
            }
        }
        let code = quickphf_codegen::build_map(&keys, &values);
        file_str.push_str(&format!("{};\n\n", code));
        n += 1;
    }
}

fn write_register_item(file_str: &mut String, item_register: &Vec<String>) {
    file_str.push_str("\npub static REGISTER_ITEM: &[RegisterItem] = &[\n");
    
    for i in item_register {
        file_str.push_str(&format!("    RegisterItem {{new: {}::new, load: {}::load, tags: {}_TAGS, name: {}::NAME}},\n", i, i, i.to_uppercase(), i));
    }
    
    file_str.push_str("];\n\n");
}

fn write_item_file(file_str: &str) {
    let path = env::current_dir().unwrap();
    let file_outpath = Path::new(&path).join("src").join("items.rs");

    let mut file_item = fs::File::create(file_outpath).unwrap();
    file_item.write_all(file_str.as_bytes()).unwrap();

    file_item.flush().unwrap();

    let path = Path::new(&env::var("OUT_DIR").unwrap()).join("items.rs");
    let mut file_item = fs::File::create(path).unwrap();
    file_item.write_all(file_str.as_bytes()).unwrap();

    file_item.flush().unwrap();
}

fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=core/");
    println!("cargo:rerun-if-changed=Cargo.lock");

    let mut file_block_str = write_header_block();

    let mut file_item_str = write_header_item();
    
    let mut block_register = vec![];
    let mut item_register = vec![];

    let mut tags: HashMap<String, Vec<(String,String)>> = HashMap::new();

    for entry in WalkDir::new("..")
        .into_iter()
        .filter_map(Result::ok)
        .filter(|e| !e.file_type().is_dir()) {
        let path = entry.path();
        let path_without_filename = path.parent().unwrap();
        let path_str = path.to_str().unwrap();

        let mut lib_path = path_str.replace("src\\", "");
        lib_path = lib_path.replace("src/", "");
        lib_path = lib_path.replace(".\\", "");
        lib_path = lib_path.replace("../", "");
        lib_path = lib_path.replace(".rs", "");
        lib_path = lib_path.replace("\\", "::");
        lib_path = lib_path.replace("/", "::");
        
        if path_str.contains("target") {
            continue;
        }

        if path_str.contains("git") {
            continue;
        }

        if path_str.ends_with(".rs") {
            let file_content = fs::read_to_string(path).unwrap();

            capture_register_block(&file_content, &mut file_block_str, &mut block_register, &lib_path);
            capture_register_item(&file_content, &mut file_item_str, &mut item_register, &lib_path);

            let re = Regex::new(r####"add_tag!\((\w+), "(\w+)", "(\w+)"\);"####).unwrap();
            for cap in re.captures_iter(&file_content) {
                if lib_path.to_lowercase().contains("blocks") {
                    let tags = tags.entry(cap[1].to_string()).or_insert(vec![]);
                    tags.push((cap[2].to_string(), cap[3].to_string()));
                } else if lib_path.to_lowercase().contains("items") {
                    let tags = tags.entry(cap[1].to_string()).or_insert(vec![]);
                    tags.push((cap[2].to_string(), cap[3].to_string()));
                }
            }

            let re = Regex::new(r####"add_tag_from_file!\((\w+), "([\w_.]+)"\);"####).unwrap();
            for cap in re.captures_iter(&file_content) {
                let tags = tags.entry(cap[1].to_string()).or_insert(vec![]);
                let file_content = fs::read_to_string(path_without_filename.join(cap[2].to_string()));
                let file_content = match file_content {
                    Ok(file_content) => file_content,
                    Err(_) => panic!("File not found: {}", path_without_filename.join(cap[2].to_string()).to_string_lossy()),
                };
                
                let re = Regex::new(r####""*([\w_]+)"* *: *"*(\w+)"*"####).unwrap();
                for cap in re.captures_iter(&file_content) {
                    tags.push((cap[1].to_string(), cap[2].to_string()));
                }
            }
        }
    }
    
    write_static_blockdata(&mut file_block_str, &block_register, &tags);
    write_register_block(&mut file_block_str, &block_register);
    write_block_file(&mut file_block_str);

    write_static_itemdata(&mut file_item_str, &item_register, &tags);
    write_register_item(&mut file_item_str, &item_register);
    write_item_file(&mut file_item_str)
}
